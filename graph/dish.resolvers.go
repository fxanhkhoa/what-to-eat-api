package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"strings"
	"what-to-eat/be/auth"
	"what-to-eat/be/graph/model"
	"what-to-eat/be/graph/service"
)

// CreateDish is the resolver for the createDish field.
func (r *mutationResolver) CreateDish(ctx context.Context, createDishInput model.CreateDishInput) (*model.Dish, error) {
	user := auth.ForContext(ctx)
	dish, err := service.NewDishService().Create(createDishInput, user)
	return dish, err
}

// UpdateDish is the resolver for the updateDish field.
func (r *mutationResolver) UpdateDish(ctx context.Context, updateDishInput model.UpdateDishInput) (*model.Dish, error) {
	user := auth.ForContext(ctx)
	dish, err := service.NewDishService().Update(updateDishInput, user)
	return dish, err
}

// RemoveDish is the resolver for the removeDish field.
func (r *mutationResolver) RemoveDish(ctx context.Context, slug string) (*model.Dish, error) {
	user := auth.ForContext(ctx)
	dish, err := service.NewDishService().Remove(slug, user)
	return dish, err
}

// Dishes is the resolver for the dishes field.
func (r *queryResolver) Dishes(
	ctx context.Context,
	keyword *string,
	page *int,
	limit *int,
	tags *string,
	preparationTimeFrom *int,
	preparationTimeTo *int,
	cookingTimeFrom *int,
	cookingTimeTo *int,
	difficultLevels *string,
	mealCategories *string,
	ingredientCategories *string,
	ingredients *string) ([]*model.Dish, error) {

	inputTags := []string{}
	if tags != nil {
		inputTags = strings.Split(*tags, ",")
	}

	inputDifficultLevels := []string{}
	if difficultLevels != nil {
		inputDifficultLevels = strings.Split(*difficultLevels, ",")
	}

	inputMealCategories := []string{}
	if mealCategories != nil {
		inputMealCategories = strings.Split(*mealCategories, ",")
	}

	inputIngredientCategories := []string{}
	if ingredientCategories != nil {
		inputIngredientCategories = strings.Split(*ingredientCategories, ",")
	}

	inputIngredients := []string{}
	if ingredients != nil {
		inputIngredients = strings.Split(*ingredients, ",")
	}

	dishes, err := service.NewDishService().Find(
		keyword,
		page,
		limit,
		&inputTags,
		preparationTimeFrom,
		preparationTimeTo,
		cookingTimeFrom,
		cookingTimeTo,
		&inputDifficultLevels,
		&inputMealCategories,
		&inputIngredientCategories,
		&inputIngredients)
	return dishes, err
}

// Dish is the resolver for the dish field.
func (r *queryResolver) Dish(ctx context.Context, slug string) (*model.Dish, error) {
	dish, err := service.NewDishService().FindOne(slug)
	return dish, err
}
